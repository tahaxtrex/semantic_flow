{
  "course_metadata": {
    "title": "DSA",
    "author": "side with the actual library implementation",
    "target_audience": "targeted at recursion, another may not, for ex- ample",
    "subject": "Unknown",
    "source": "Dsa.pdf",
    "description": "implementations of common and uncommon algorithms in pseudocodewhichislanguageindependentandprovidesforeasyportingtomost imperative programming languages.",
    "prerequisites": [
      "No formal prerequisites required"
    ],
    "learning_outcomes": [],
    "publisher": "Unknown",
    "year": "2008",
    "isbn": "Unknown",
    "level": "Introductory",
    "contributing_authors": []
  },
  "overall_score": {
    "goal_focus": 0.0,
    "text_readability": 0.0,
    "pedagogical_clarity": 0.0,
    "prerequisite_alignment": 0.0,
    "fluidity_continuity": 0.0,
    "structural_usability": 0.0,
    "example_concreteness": 0.0,
    "example_coherence": 0.0,
    "business_relevance": 0.0,
    "instructional_alignment": 0.0
  },
  "segments": [
    {
      "segment_id": 1,
      "heading": "Annotated Reference with Examples",
      "text": "First Edition\nCopyright [?] c Granville Barnett, and Luca Del Tongo 2008.\nThis book is made exclusively available from DotNetSlackers\n( http://dotnetslackers.com/ ) the place for .NET articles, and news from\nsome of the leading minds in the software industry.\n\n1 Introduction 1\n1.1 What this book is, and what it isn’t . . . . . . . . . . . . . . . . 1\n1.2 Assumed knowledge . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2.1 Big Oh notation . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2.2 Imperative programming language . . . . . . . . . . . . . 3\n1.2.3 Object oriented concepts . . . . . . . . . . . . . . . . . . 4\n1.3 Pseudocode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.4 Tips for working through the examples . . . . . . . . . . . . . . . 6\n1.5 Book outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.6 Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.7 Where can I get the code? . . . . . . . . . . . . . . . . . . . . . . 7\n1.8 Final messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\nI Data Structures 8\n2 Linked Lists 9\n2.1 Singly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.1.1 Insertion. . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.1.2 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.1.3 Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n2.1.4 Traversing the list . . . . . . . . . . . . . . . . . . . . . . 12\n2.1.5 Traversing the list in reverse order . . . . . . . . . . . . . 13\n2.2 Doubly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2.2.1 Insertion. . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.2.2 Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.2.3 Reverse Traversal . . . . . . . . . . . . . . . . . . . . . . . 16\n2.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n3 Binary Search Tree 19\n3.1 Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n3.2 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n3.3 Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n3.4 Finding the parent of a given node . . . . . . . . . . . . . . . . . 24\n3.5 Attaining a reference to a node . . . . . . . . . . . . . . . . . . . 24\n3.6 Finding the smallest and largest values in the binary search tree 25\n3.7 Tree Traversals . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n3.7.1 Preorder . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nI\n3.7.2 Postorder . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n3.7.3 Inorder . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n3.7.4 Breadth First . . . . . . . . . . . . . . . . . . . . . . . . . 30\n3.8 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n4 Heap 32\n4.1 Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n4.2 Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n4.3 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n4.4 Traversal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n4.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n5 Sets 44\n5.1 Unordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n5.1.1 Insertion. . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n5.2 Ordered . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n5.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n6 Queues 48\n6.1 A standard queue . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n6.2 Priority Queue . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\n6.3 Double Ended Queue . . . . . . . . . . . . . . . . . . . . . . . . . 49\n6.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\n7 AVL Tree 54\n7.1 Tree Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n7.2 Tree Rebalancing . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n7.3 Insertion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58\n7.4 Deletion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n7.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nII Algorithms 62\n8 Sorting 63\n8.1 Bubble Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n8.2 Merge Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n8.3 Quick Sort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n8.4 Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n8.5 Shell Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n8.6 Radix Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n8.7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n9 Numeric 72\n9.1 Primality Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n9.2 Base conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n9.3 Attaining the greatest common denominator of two numbers . . 73\n9.4 Computing the maximum value for a number of a specific base\nconsisting of N digits . . . . . . . . . . . . . . . . . . . . . . . . . 74\n9.5 Factorial of a number . . . . . . . . . . . . . . . . . . . . . . . . 74\n9.6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nII\n10 Searching 76\n10.1 Sequential Search . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n10.2 Probability Search . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n10.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n11 Strings 79\n11.1 Reversing the order of words in a sentence . . . . . . . . . . . . . 79\n11.2 Detecting a palindrome . . . . . . . . . . . . . . . . . . . . . . . 80\n11.3 Counting the number of words in a string . . . . . . . . . . . . . 81\n11.4 Determining the number of repeated words within a string . . . . 83\n11.5 Determining the first matching character between two strings . . 84\n11.6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nA Algorithm Walkthrough 86\nA.1 Iterative algorithms . . . . . . . . . . . . . . . . . . . . . . . . . 86\nA.2 Recursive Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . 88\nA.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nB Translation Walkthrough 91\nB.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\nC Recursive Vs. Iterative Solutions 93\nC.1 Activation Records . . . . . . . . . . . . . . . . . . . . . . . . . . 94\nC.2 Some problems are recursive in nature . . . . . . . . . . . . . . . 95\nC.3 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\nD Testing 97\nD.1 What constitutes a unit test? . . . . . . . . . . . . . . . . . . . . 97\nD.2 When should I write my tests? . . . . . . . . . . . . . . . . . . . 98\nD.3 How seriously should I view my test suite? . . . . . . . . . . . . . 99\nD.4 The three A’s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nD.5 The structuring of tests . . . . . . . . . . . . . . . . . . . . . . . 99\nD.6 Code Coverage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\nD.7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\nE Symbol Definitions 101\nIII",
      "segment_type": "exercise",
      "scores": {
        "goal_focus": 0,
        "text_readability": 0,
        "pedagogical_clarity": 0,
        "prerequisite_alignment": 0,
        "fluidity_continuity": 0,
        "structural_usability": 0,
        "example_concreteness": 0,
        "example_coherence": 0,
        "business_relevance": 0,
        "instructional_alignment": 0
      },
      "reasoning": {
        "goal_focus_rationale": "N/A",
        "text_readability_rationale": "N/A",
        "pedagogical_clarity_rationale": "N/A",
        "prerequisite_alignment_rationale": "N/A",
        "fluidity_continuity_rationale": "N/A",
        "structural_usability_rationale": "N/A",
        "example_concreteness_rationale": "N/A",
        "example_coherence_rationale": "N/A",
        "business_relevance_rationale": "N/A",
        "instructional_alignment_rationale": "N/A"
      },
      "incomplete": false
    },
    {
      "segment_id": 2,
      "heading": "Preface",
      "text": "Every book has a story as to how it came about and this one is no different,\nalthough we would be lying if we said its development had not been somewhat\nimpromptu. Put simply this book is the result of a series of emails sent back\nand forth between the two authors during the development of a library for\nthe .NET framework of the same name (with the omission of the subtitle of\ncourse!). The conversation started off something like, “Why don’t we create\na more aesthetically pleasing way to present our pseudocode?” After a few\nweeks this new presentation style had in fact grown into pseudocode listings\nwith chunks of text describing how the data structure or algorithm in question\nworks and various other things about it. At this point we thought, “What the\nheck, let’s make this thing into a book!” And so, in the summer of 2008 we\nbegan work on this book side by side with the actual library implementation.\nWhen we started writing this book the only things that we were sure about\nwith respect to how the book should be structured were:\n1. alwaysmakeexplanationsassimpleaspossiblewhilemaintainingamoder-\natelyfinedegreeofprecisiontokeepthemoreeagermindedreaderhappy;\nand\n2. injectdiagramstodemystifyproblemsthatareevenmoderatlychallenging\ntovisualise(...andsowecouldrememberhowourownalgorithmsworked\nwhen looking back at them!); and finally\n3. presentconciseandself-explanatorypseudocodelistingsthatcanbeported\neasily to most mainstream imperative programming languages like C++,\nC#, and Java.\nA key factor of this book and its associated implementations is that all\nalgorithms (unless otherwise stated) were designed by us, using the theory of\nthe algorithm in question as a guideline (for which we are eternally grateful to\ntheir original creators). Therefore they may sometimes turn out to be worse\nthan the “normal” implementations—and sometimes not. We are two fellows\nof the opinion that choice is a great thing. Read our book, read several others\non the same subject and use what you see fit from each (if anything) when\nimplementing your own version of the algorithms in question.\nThroughthisbookwehopethatyouwillseetheabsolutenecessityofunder-\nstanding which data structure or algorithm to use for a certain scenario. In all\nprojects, especially those that are concerned with performance (here we apply\nan even greater emphasis on real-time systems) the selection of the wrong data\nstructure or algorithm can be the cause of a great deal of performance pain.\nIV\nV\nThereforeitisabsolutelykeythatyouthinkabouttheruntimecomplexityand\nspace requirements of your selected approach. In this book we only explain the\ntheoreticalimplications to consider, but this is fora good reason: compilers are\nvery different in how they work. One C++ compiler may have some amazing\noptimisation phases specifically targeted at recursion, another may not, for ex-\nample. Of course this is just an example but you would be surprised by how\nmany subtle differences there are between compilers. These differences which\nmay make a fast algorithm slow, and vice versa. We could also factor in the\nsame concerns about languages that target virtual machines, leaving all the\nactual various implementation issues to you given that you will know your lan-\nguage’s compiler much better than us...well in most cases. This has resulted in\na more concise book that focuses on what we think are the key issues.\nOne final note: never take the words of others as gospel; verify all that can\nbe feasibly verified and make up your own mind.\nWehopeyouenjoyreadingthisbookasmuchaswehaveenjoyedwritingit.\nGranville Barnett\nLuca Del Tongo\n\nWriting this short book has been a fun and rewarding experience. We would\nlike to thank, in no particular order the following people who have helped us\nduring the writing of this book.\nSonu Kapoor generously hosted our book which when we released the first\ndraft received over thirteen thousand downloads, without his generosity this\nbook wouldnot havebeen ableto reachso manypeople. Jon Skeetprovidedus\nwith an alarming number of suggestions throughout for which we are eternally\ngrateful. Jon also edited this book as well.\nWewouldalsoliketothankthosewhoprovidedtheoddsuggestionviaemail\nto us. All feedback was listened to and you will no doubt see some content\ninfluenced by your suggestions.\nA special thank you also goes out to those who helped publicise this book\nfrom Microsoft’s Channel 9 weekly show (thanks Dan!) to the many bloggers\nwho helped spread the word. You gave us an audience and for that we are\nextremely grateful.\nThank you to all who contributed in some way to this book. The program-\nming community never ceases to amaze us in howwilling its constituentsare to\ngive time to projects such as this one. Thank you.\nVI\n\nGranvilleiscurrentlyaPh.DcandidateatQueenslandUniversityofTechnology\n(QUT)workingonparallelismattheMicrosoftQUTeResearchCentre . Healso\nholdsadegreeinComputerScience,andisaMicrosoftMVP.Hismaininterests\nare in programming languages and compilers. Granville can be contacted via\none of two places: either his personal website ( http://gbarnett.org ) or his\nblog ( http://msmvps.com/blogs/gbarnett ).\n\nLuca is currently studying for his masters degree in Computer Science at Flo-\nrence. His main interests vary from web development to research fields such as\ndata mining and computer vision. Luca also maintains an Italian blog which\ncan be found at http://blogs.ugidotnet.org/wetblog/ .\nhttp://www.mquter.qut.edu.au/\nVII\nPage intentionally left blank.\n\nThis book provides implementations of common and uncommon algorithms in\npseudocodewhichislanguageindependentandprovidesforeasyportingtomost\nimperative programming languages. It is not a definitive book on the theory of\ndata structures and algorithms.\nForthemostpartthisbookpresentsimplementationsdevisedbytheauthors\nthemselves based on the concepts by which the respective algorithms are based\nupon so it is more than possible that our implementations differ from those\nconsidered the norm.\nYou should use this book alongside another on the same subject, but one\nthat contains formal proofs of the algorithms in question. In this book we use\nthe abstract big Oh notation to depict the run time complexity of algorithms\nso that the book appeals to a larger audience.",
      "segment_type": "frontmatter",
      "scores": {
        "goal_focus": 0,
        "text_readability": 0,
        "pedagogical_clarity": 0,
        "prerequisite_alignment": 0,
        "fluidity_continuity": 0,
        "structural_usability": 0,
        "example_concreteness": 0,
        "example_coherence": 0,
        "business_relevance": 0,
        "instructional_alignment": 0
      },
      "reasoning": {
        "goal_focus_rationale": "N/A",
        "text_readability_rationale": "N/A",
        "pedagogical_clarity_rationale": "N/A",
        "prerequisite_alignment_rationale": "N/A",
        "fluidity_continuity_rationale": "N/A",
        "structural_usability_rationale": "N/A",
        "example_concreteness_rationale": "N/A",
        "example_coherence_rationale": "N/A",
        "business_relevance_rationale": "N/A",
        "instructional_alignment_rationale": "N/A"
      },
      "incomplete": false
    }
  ],
  "evaluation_meta": {
    "model_used": "Gemini-2.5-Flash",
    "timestamp": "2026-02-28T13:27:02.576827+00:00",
    "prompt_version": "1.1",
    "total_segments": 2,
    "instructional_segments_scored": 2,
    "excluded_segments": 0
  }
}